if (!("a" in window)) {
  var a = 1;
}
alert(a);
// Не понимаю , что значит выражение !("a" in window) , но скорее всего по этому выражению нельзя попасть в условие if  и присвоить значение переменной 1, а так как  переменная a обьявлена через var, то при всплытии инициализации произойдет в window со значением undefind  и в alert выведется undefind

var b = function a(x) {
  x && a(--x);
};
alert(a);
// функция a не инициализирована, поэтому вывод будет ошибкой. если убрать присвоение к переменной b , тогда инициализация произойдет и в alert будет выведена сама функция.


function a(x) {
  return x * 2;
}
var a;
alert(a);
// переменная a обьявлена через var, при всплытии ее значение undefind. далее a присваивается функция и в alert выведется  сама функция


function b(x, y, a) {
  arguments[2] = 10;
  alert(a);
}
b(1, 2, 3);
// Объект arguments — это подобный массиву объект, который содержит аргументы, переданные в функцию. Примечание: "Подобный массиву" означает, что arguments имеет свойство length, а элементы индексируются начиная с нуля (из документации). Функция b принимает 3 значения. индекс значения a - это 2 . В теле функции присваиваем индексу 2 , те a значение 10 и выводим в alert. Поэтому вывод будет  10

function a() {
  alert(this);
}
a.call(null);
// функция a определена в window, поэтому this для нее будет window. вызываем функцию а в контексте null . если метод является функцией в нестрогом режиме, значения null и undefined будут заменены глобальным объектом (из документации) . Глобальный обьект для функции a - это window. поэтому в alert должно вывести window